"""
LiveKit Voice Agent Implementation
Integrates with the website's agent management system
"""
import os
import json
import asyncio
import logging
from typing import Dict, Any, Optional
from dotenv import load_dotenv

from livekit import agents
from livekit.agents import AgentSession, Agent, RoomInputOptions
from livekit.plugins import openai, noise_cancellation
from livekit.agents.llm import ChatContext, ChatMessage

from voice_agents.prompts import get_voice_agent_prompt, get_greeting_prompt
from backend.services.agent_tools import get_agent_tools
from backend.services.database_service import DatabaseService
from backend.models import get_db

load_dotenv()

logger = logging.getLogger(__name__)


class WebsiteVoiceAgent(Agent):
    """Voice Agent that integrates with the website's agent management system"""
    
    def __init__(self, agent_id: int, agent_config: Dict[str, Any]):
        """Initialize voice agent with configuration from website
        
        Args:
            agent_id: ID of the agent from the database
            agent_config: Agent configuration generated by meta agent
        """
        self.agent_id = agent_id
        self.agent_config = agent_config
        self.db = next(get_db())
        
        # Get agent data from database
        self.agent_data = DatabaseService.get_agent(self.db, agent_id)
        if not self.agent_data:
            raise ValueError(f"Agent {agent_id} not found in database")
        
        # Parse the system prompt configuration
        if self.agent_data.system_prompt:
            try:
                self.prompt_components = json.loads(self.agent_data.system_prompt)
            except json.JSONDecodeError:
                logger.warning(f"Could not parse system prompt for agent {agent_id}")
                self.prompt_components = {}
        else:
            self.prompt_components = {}
        
        # Build the system instructions
        instructions = self._build_system_instructions()
        
        # Get agent tools
        agent_tools = get_agent_tools(agent_id)
        
        super().__init__(
            instructions=instructions,
            tools=agent_tools
        )
    
    def _build_system_instructions(self) -> str:
        """Build system instructions from agent configuration"""
        try:
            # Get the voice agent prompt template
            prompt_template = get_voice_agent_prompt()
            
            # Prepare prompt variables from agent configuration
            prompt_vars = {
                'agent_name': self.agent_data.name or 'AI Assistant',
                'company_name': self.agent_data.company_name or 'Our Company',
                'agent_role_description': self.prompt_components.get('agent_role_description', 'a helpful AI assistant'),
                'personality_traits': self.prompt_components.get('personality_traits', 'professional and friendly'),
                'communication_style': self.prompt_components.get('communication_style', 'clear and helpful'),
                'company_description': self.prompt_components.get('company_description', 'a business focused on customer service'),
                'main_services': self.prompt_components.get('main_services', 'various services to help our customers'),
                'target_audience': self.prompt_components.get('target_audience', 'customers seeking assistance'),
                'business_hours': self.prompt_components.get('business_hours', 'standard business hours'),
                'key_value_proposition': self.prompt_components.get('key_value_proposition', 'excellent service and support'),
                'greeting_script': self.prompt_components.get('greeting_script', f"Hello! I'm {self.agent_data.name}, how can I help you today?"),
                'conversation_boundaries': self.prompt_components.get('conversation_boundaries', 'helping with customer inquiries'),
                'escalation_rules': self.prompt_components.get('escalation_rules', 'complex issues or when requested by customer'),
                'knowledge_scope': self.prompt_components.get('knowledge_scope', 'company information and general assistance'),
                'available_tools_description': self.prompt_components.get('available_tools_description', 'knowledge search, business info, and lead capture'),
                'lead_capture_approach': self.prompt_components.get('lead_capture_approach', 'helpful and non-intrusive'),
                'appointment_booking_rules': self.prompt_components.get('appointment_booking_rules', 'assist with scheduling when requested'),
                'transfer_process': self.prompt_components.get('transfer_process', 'connect with human representatives when needed'),
                'response_style': self.prompt_components.get('response_style', 'conversational and natural'),
                'knowledge_handling': self.prompt_components.get('knowledge_handling', 'search knowledge base for accurate information'),
                'uncertainty_handling': self.prompt_components.get('uncertainty_handling', 'admit when unsure and offer alternatives'),
                'conversation_flow': self.prompt_components.get('conversation_flow', 'natural and engaging dialogue'),
                'input': '{input}'  # Placeholder for user input
            }
            
            # Format the prompt template
            formatted_messages = prompt_template.format_messages(**prompt_vars)
            
            # Extract the system message
            for message in formatted_messages:
                if hasattr(message, 'type') and message.type == 'system':
                    return message.content
            
            # Fallback to simple instructions
            return f"You are {self.agent_data.name}, an AI assistant for {self.agent_data.company_name}. Be helpful and professional."
            
        except Exception as e:
            logger.error(f"Error building system instructions for agent {self.agent_id}: {str(e)}")
            # Fallback instructions
            return f"You are {self.agent_data.name or 'AI Assistant'}, a helpful voice assistant. Assist customers professionally and use available tools when needed."
    
    def get_greeting_message(self) -> str:
        """Get the initial greeting message for the agent"""
        try:
            greeting = self.prompt_components.get('greeting_script')
            if greeting:
                return greeting
            
            # Generate dynamic greeting
            greeting_prompt = get_greeting_prompt()
            formatted_messages = greeting_prompt.format_messages(
                agent_name=self.agent_data.name or 'AI Assistant',
                company_name=self.agent_data.company_name or 'Our Company'
            )
            
            # Extract greeting (in production, you'd use an LLM to generate this)
            return f"Hello! I'm {self.agent_data.name}, your AI assistant from {self.agent_data.company_name}. How can I help you today?"
            
        except Exception as e:
            logger.error(f"Error getting greeting for agent {self.agent_id}: {str(e)}")
            return "Hello! How can I assist you today?"


class VoiceAgentManager:
    """Manages voice agent sessions and integrates with website"""
    
    def __init__(self):
        self.active_sessions: Dict[str, AgentSession] = {}
        self.agents: Dict[int, WebsiteVoiceAgent] = {}
    
    async def create_agent_session(self, agent_id: int, room_name: str) -> AgentSession:
        """Create a new agent session for the specified agent
        
        Args:
            agent_id: ID of the agent from database
            room_name: LiveKit room name
            
        Returns:
            AgentSession instance
        """
        try:
            # Get agent from database
            db = next(get_db())
            agent_data = DatabaseService.get_agent(db, agent_id)
            
            if not agent_data:
                raise ValueError(f"Agent {agent_id} not found")
            
            if agent_data.status != 'created':
                raise ValueError(f"Agent {agent_id} is not ready (status: {agent_data.status})")
            
            # Create the voice agent
            agent_config = {}
            if agent_data.system_prompt:
                try:
                    agent_config = json.loads(agent_data.system_prompt)
                except json.JSONDecodeError:
                    logger.warning(f"Could not parse agent config for {agent_id}")
            
            voice_agent = WebsiteVoiceAgent(agent_id, agent_config)
            self.agents[agent_id] = voice_agent
            
            # Create agent session with voice configuration
            voice_id = agent_data.voice_id or 'alloy'
            session = AgentSession(
                llm=openai.realtime.RealtimeModel(
                    voice=voice_id,
                    temperature=0.7,
                    instructions=voice_agent.instructions
                )
            )
            
            self.active_sessions[room_name] = session
            
            logger.info(f"Created agent session for agent {agent_id} in room {room_name}")
            return session
            
        except Exception as e:
            logger.error(f"Error creating agent session: {str(e)}")
            raise
    
    async def start_session(self, session: AgentSession, room, agent_id: int):
        """Start the agent session in a room
        
        Args:
            session: The agent session
            room: LiveKit room
            agent_id: Agent ID
        """
        try:
            agent = self.agents.get(agent_id)
            if not agent:
                raise ValueError(f"Agent {agent_id} not found in manager")
            
            await session.start(
                room=room,
                agent=agent,
                room_input_options=RoomInputOptions(
                    noise_cancellation=noise_cancellation.BVC(),
                ),
            )
            
            # Generate initial greeting
            greeting = agent.get_greeting_message()
            await session.generate_reply(instructions=greeting)
            
            logger.info(f"Started session for agent {agent_id}")
            
        except Exception as e:
            logger.error(f"Error starting session for agent {agent_id}: {str(e)}")
            raise
    
    def get_session(self, room_name: str) -> Optional[AgentSession]:
        """Get active session for a room"""
        return self.active_sessions.get(room_name)
    
    def cleanup_session(self, room_name: str):
        """Clean up session when room is closed"""
        if room_name in self.active_sessions:
            del self.active_sessions[room_name]
            logger.info(f"Cleaned up session for room {room_name}")


# Global agent manager instance
agent_manager = VoiceAgentManager()


async def entrypoint(ctx: agents.JobContext):
    """LiveKit agent entrypoint - called when agent connects to room
    
    Args:
        ctx: Job context from LiveKit
    """
    try:
        # Extract agent ID from room metadata or name
        room_name = ctx.room.name
        agent_id = None
        
        # Parse agent ID from room name (format: "agent-{agent_id}-{session_id}")
        if room_name.startswith("agent-"):
            parts = room_name.split("-")
            if len(parts) >= 2:
                try:
                    agent_id = int(parts[1])
                except ValueError:
                    logger.error(f"Invalid agent ID in room name: {room_name}")
                    return
        
        if not agent_id:
            logger.error(f"Could not extract agent ID from room name: {room_name}")
            return
        
        # Create and start agent session
        session = await agent_manager.create_agent_session(agent_id, room_name)
        await agent_manager.start_session(session, ctx.room, agent_id)
        
        logger.info(f"Agent {agent_id} connected to room {room_name}")
        
    except Exception as e:
        logger.error(f"Error in agent entrypoint: {str(e)}")
        # Still try to provide basic service
        session = AgentSession(
            llm=openai.realtime.RealtimeModel(voice="alloy")
        )
        
        # Create basic fallback agent
        fallback_agent = Agent(
            instructions="I'm an AI assistant. I'm experiencing some technical difficulties but I'm here to help as best I can."
        )
        
        await session.start(room=ctx.room, agent=fallback_agent)
        await session.generate_reply(
            instructions="Hello! I'm your AI assistant. I'm experiencing some technical issues but I'm still here to help. How can I assist you today?"
        )


if __name__ == "__main__":
    # Run the agent worker
    agents.cli.run_app(agents.WorkerOptions(entrypoint_fnc=entrypoint))
